### 内容

- 算法
- 实现
- 正确性证明
- 运行时间和空间
- 引文



给定一个数 $n$，问题是是找到区间 $\left[2,n\right]$ 之间的所有素数。这个问题标准的解法是使用素数筛算法，该算法很简洁，时间复杂度是 $O(n\log n\log n)$



尽管线性时间的算法不少，但下文描述的算法的很有趣，因为它并不比标准的素数筛复杂多少。除此以外，下文的算法还能顺带计算区间 $\left[2,n\right]$ 内的数的素因数分解，这在许多问题中也是很有用的。它的缺点是要使用更多的内存，传统的素数筛对 $\left[2,n\right]$ 之间的每个数只保存它是否为素数，空间可以是1bit，而下文算法则必须保存一个4字节的整数，空间开销是32倍。因此，在算法竞赛中下文算法只能用来处理不超过 $10^7$ 的数据范围



该算法的作者是 Gries & Misra（见本文引文章节）。并且严格来讲，这个算法不一样叫做素数筛，因为它和标准素数筛的差别很大



### 算法

我们的目标是为区间 $\left[2,n\right]$ 之间的每个数 $i$ 计算它最小的素因子 $lp[i]$，除此以外，我们还会记录所有已发现的素数，记为 $pr[]$



lp数组的每个元素初始化为0，代表我们认为每个数都是潜在的素数。在遍历 $\left[2,n\right]$ 的过程中，对当前数 $i$ 有两种情况：

- $lp[i]=0$：代表 $i$ 是一个素数（没有找到比i小并且能整除i的素数）。我们记 $lp[i]=i$ 并把 $i$ 加到 $pr[]$ 中
- $lp[i]\neq 0$：代表 $i$ 是一个合数，并且它最小的素因子是 $lp[i]$

两种情况下我们都更新所有 $i$ 的倍数的 $lp$ 值，为了满足线性时间的限制，我们的目标是每个数的 $lp$ 值都只更新一次。可以这么做：



考虑一组数 $x_j=i\cdot p_j$，其中 $p_1,p_2,...p_j,...$ 是所有比 $lp[i]$ 小的素数（所以我们要用 $pr[]$ 存储所有的素数）。 $x_j$ 的lp值会被设为 $p_j$。下面是实现和一些证明



### 实现

```c++
const int N = 10000000;
int lp[N+1];
vector<int> pr;

for (int i=2; i<=N; ++i) {
    if (lp[i] == 0) {
        lp[i] = i;
        pr.push_back (i);
    }
    for (int j=0; j<(int)pr.size() && pr[j]<=lp[i] && i*pr[j]<=N; ++j)
        lp[i * pr[j]] = pr[j];
}
```



### 正确性证明

我们需要证明每个 $lp[]$ 值都是正确的并且只被设置了一次





### 运行时间和空间



### 引文

- David Gries, Jayadev Misra. **A Linear Sieve Algorithm for Finding Prime Numbers** [1978]